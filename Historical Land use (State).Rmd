---
title: "HLL (state)"
author: "JayToh"
date: '2023-05-08'
output: html_document
---

# Library:
```{r}
library(ncdf4) # package for netcdf manipulation
library(tidyr)
library(dplyr)
```

# Guidance:
https://pjbartlein.github.io/REarthSysSci/netCDF.html 
https://towardsdatascience.com/how-to-crack-open-netcdf-files-in-r-and-extract-data-as-time-series-24107b70dcd 

# Data:
1. Open nc file, print (summary)
     4 dimensions:
        time  Size:1166   *** is unlimited *** 
            units: years since 850-01-01 0:0:0
            calendar: noleap
            long_name: time
            standard_name: time
            axis: T
        lat  Size:720 
            units: degrees_north
            long_name: latitude
            standard_name: latitude
            axis: Y
        lon  Size:1440 
            units: degrees_east
            long_name: longitude
            standard_name: longitude
            axis: X
        bounds  Size:2 (no dimvar)
```{r}

Historical_Land <- nc_open("states.nc")
print(Historical_Land)

```

# Coordinates:
```{r}
####### Longitude #######
lon <- ncvar_get(Historical_Land,"lon")
dim(lon) # 1440, matched the data
range(lon) # -179.875 to 179.875

####### Latitude #######
lat <- ncvar_get(Historical_Land,"lat")
dim(lat) # 720, matched the data
range(lat) # -89.875 to 89.875
```

# Overall time
```{r}
###### One time code! #####
# Changing time to start with 850
Historical_Land$dim$time$vals <- Historical_Land$dim$time$vals + 850
Historical_Land$dim$time # checking
object.size(Historical_Land) # 658944 bytes


####### Time #######
time <- ncvar_get(Historical_Land,"time") + 850
dim(time) # 1166, matched the data, years since 850-01-01 0:0:0
range(time) # 850~2015
time

```


# Reshape the whole array:
## Primf
```{r}
EzVar <- function(var){
  A <- ncvar_get(Historical_Land, var)
  fillvalue <- ncatt_get(Historical_Land, var, "_FillValue")
  A[A==fillvalue$value] <- NA
  A
}

lonlat <- as.matrix(expand.grid(lon, lat))

##### Getting the desired land use
Primf <- EzVar("primf")
dim(Primf) # 1440  720 1166 = Lon  Lat  Time

## Convert to vector
Primf_long <- as.vector(Primf)
length(Primf_long)

## Memory issue, remove!
rm(Primf_long)
rm(Historical_Land)

## Convert to matrix with lon, lat, time 
PV_mat <- matrix(Primf_long, nrow = dim(lon)*dim(lat), ncol = dim(time))
dim(PV_mat)

## Convert to dataframe by cbining lonlat with the matrix above!
PV_mat2 <- data.frame(cbind(lonlat, PV_mat))

## ************ Remove NAs (don't need to this step) ************ ##
PV_mat3 <- na.omit(PV_mat2) 

## Naming the columns
names(PV_mat3) <- c("Lon", "Lat", 849+(seq(1:1166)))
```

## Primn
```{r}

Ezmatrix <- function(DF){
  A <- as.vector(DF)
  B <- matrix(A, nrow = dim(lon)*dim(lat), ncol = dim(time))
  C <- data.frame(cbind(lonlat, B)) 
  names(C) <- c("Lon", "Lat", 849+(seq(1:1166)))
  C
}

Primn <- EzVar("primn")

Primn_long <- as.vector(Primf)
Pn_mat <- matrix(Primn_long, nrow = dim(lon)*dim(lat), ncol = dim(time))
Pn_mat2 <- data.frame(cbind(lonlat, Pn_mat))

names(Pn_mat2) <- c("Lon", "Lat", 849+(seq(1:1166)))
```



# Matching test
```{r}
lonlat_df <- data.frame(lonlat) 
names(lonlat_df) <- c("Lon", "Lat")

#### Max and min of each Long and Lat
lonlat_df <- lonlat_df %>% mutate(Lon_max = Lon + 0.125,
                                  Lon_min = Lon - 0.125,
                                  Lat_max = Lat + 0.125,
                                  Lat_min = Lat - 0.125) %>% relocate(Lat, .before = Lat_max)
lon_df <- lonlat_df %>% select(Lon, Lon_max, Lon_min) %>% mutate(X = 1) %>% group_by(Lon, Lon_max, Lon_min) %>% summarise(Y = sum(X)) %>% select(-Y)
lat_df <- lonlat_df %>% select(Lat, Lat_max, Lat_min) %>% mutate(X = 1) %>% group_by(Lat, Lat_max, Lat_min) %>% summarise(Y = sum(X)) %>% select(-Y)

#### Exp 
Consumers <- read.csv("Consumers_lonlat.csv") %>% select(-X)
Consumers_test <- Consumers %>% mutate(Lon_new = ifelse(Longitude < lon_df$Lon_max & Longitude > lon_df$Lon_min, lon_df$Lon, "NA"))


Ezlocation <- function(DF){
  df <- rep(NA, length(DF))

  for(values in DF$Longitude){
  df[values] <- (ifelse(values < lon_df$Lon_max & values > lon_df$Lon_min, lon_df$Lon, NA)) 
}
}

Testing <- Ezlocation(Consumers)


#### Function:
# -155.3527

EzLonlat <- function(val){
  A <- lon_df
  B <- ifelse(val <= A$Lon_max & val >= A$Lon_min, A$Lon, NA)
  C <- B %>% na.omit()
  D <- C %>% as.numeric()
  D
}
EzLonlat(-155.3527)

EzLonlat(Consumers_head$Longitude)

c(1, 3, 2, NA, 3, 4) %>% na.omit() %>% as.numeric()
```


```{r}
##### Data for testing
Consumers_head <- head(Consumers, 3) # Initial test with this dataset, VERY useful XDDD

Consumers1 <- drop_na(Consumers %>% select(-Years_since)) # Cannot have NA in Lon and Lat or will cause problems


# Function
Ezforlocation <- function(DF) {
  A <- DF$Longitude
  B <- numeric()
  for(values in 1:length(A)) {
  B[values]  <- ifelse(A[values] < lon_df$Lon_max & A[values] >= lon_df$Lon_min, lon_df$Lon, NA) %>% na.omit() %>% as.numeric()
  }
  
  C <- B %>% data.frame(Lon = A, Lon_grid = B)
  C <- C[,2:3]
  
  D <- DF$Latitude
  E <- numeric()
  for(values in 1:length(D)) {
  E[values]  <- ifelse(D[values] < lat_df$Lat_max & D[values] >= lat_df$Lat_min, lat_df$Lat, NA) %>% na.omit() %>% as.numeric()
  }
  
  FF <- E %>% data.frame(Lat = D, Lat_grid = E)
  FF <- FF[,2:3]
  G <- cbind(C, FF) %>% relocate(Lat, .after = Lon)
}

Test <- Ezforlocation(Consumers_head)
Testing1 <- Ezforlocation(Consumers1)

  



#### Raw codes for testing ####
CC <- rep(1 , length(Consumers_head)-1)
CC <- numeric()
class(CC)
Consumers_head$Longitude
CL <- c(Consumers1$Longitude)
CL

 for(values in 1:length(CL)) {
  CC[values]  <- ifelse(CL[values] <= lon_df$Lon_max & CL[values] >= lon_df$Lon_min, lon_df$Lon, NA) %>% na.omit() %>% as.numeric()
}
CC

```


# Quick function to get variable in DF:
1. Get the variable
2. Get the _Fillvalue
3. Patch the fillvalue with NA
```{r}



##### Slicing #####
Primf1 <- Primf[,,50]

```

# Human readable time: Skip this for now, not working properly
https://stackoverflow.com/questions/46001573/convert-a-netcdf-time-variable-to-an-r-date-object
POSIXct object: Origin or day/hour zero of the time source. If the source is a netCDF file, this value is ignored and is read from that file.
Thus it is enough to simply pass the netcdf connection as the first argument and the function handles the rest. Caveat: *This will only work if the netCDF file follows CF conventions (e.g. if your units are "years since" instead of "seconds since" or "days since" it will fail for example)*.


```{r}
print(time)
########### WRONG: Since seconds ##########
time_obs <- as.POSIXct(time*31536000, origin = "0850-01-01", format = "%Y") # NOT good, this converts to second, but the unit is in years...
dim(time_obs) # 1165, still the same, nice!
range(time_obs)
?as.POSIXct()
########### Approximate Years ##########
tustr <- strsplit(tunits$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])
tyear <- as.integer(unlist(tdstr)[1])
chron(time*365, origin =c(tmonth, tday, tyear), format = "m-d-year")

########### function Years ##########
Eztime <- function(TU){
tustr <- strsplit(TU$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])
tyear <- as.integer(unlist(tdstr)[1])
HERE <- chron((time*365), origin =c(tmonth, tday, tyear), format = "m-d-year")
HERE
}


```   

# Creating DF

```{r}
lonlat <- as.matrix(expand.grid(lon,lat, time)) # Cannot compute time: Error message is "Error: cannot allocate vector of size 27.0 Gb"
lonlat <- data.frame(cbind(lonlat, time))



```

